# 红黑树

> 红黑树是一种含有红黑节点并能自平衡的二叉查找树。

### 性质:

含有以下五个性质：

1. 每个节点要么是红色，要么是黑色。
2. 根节点是黑色。（规定！规定！规定！！！）
3. 每个叶子节点（NIL）都是黑色的虚节点。
4. 每个红色节点的两个子节点一定是黑色。
5. 任意一节点到每个叶子节点的路径都包含数量相同的黑节点。(黑色完美平衡)

> Nil和Null的区别：
>
> Nil:表示无值（概念）用于区分其他值
>
> Null:是计算机中具有保留的值（概念）用于指示指针不引用有效对象

> 每个节点要么是红色，要么是黑色。
>
> ![](https://raw.githubusercontent.com/Mini-Bar/MyPicture/main/pic/image-20201210091854620.png)

> 根节点是黑色。（规定！规定！规定！！！）
>
> ![](https://github.com/Mini-Bar/MyPicture/blob/main/pic/image-20201210091957908.png?raw=true)

> 每个叶子节点（NIL）都是黑色的虚节点。
>
> ![image-20201210092327054.png](https://raw.githubusercontent.com/Mini-Bar/MyPicture/main/pic/image-20201210092327054.png)

> 每个红色节点的两个子节点一定是黑色
>
> ![image-20201210092327054.png](https://raw.githubusercontent.com/Mini-Bar/MyPicture/main/pic/image-20201210093148189.png)

> 任意一节点到每个叶子节点的路径都包含数量相同的黑节点
>
> ![image-20201210092327054.png](https://raw.githubusercontent.com/Mini-Bar/MyPicture/main/pic/image-20201210092327054.png)
>
> 可以转换为：![image-20201210093807474](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210094441429.png)

#### 二叉查找树（又称二叉排序树）

> 一般定义：
>
> 1：若左子树不空，则左子树上所有节点的值均小于他的根节点的值
>
> 2：若右子树不空，则右子树上所有节点的值均大于或等于他的根节点的值
>
> 3：左右子树也分别为二叉排序树
>
> ![image-20201210094441429](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210094441429.png)



##### 满足约束：左节点小于父节点，右节点大于父节点。

> 每棵子树头节点的值都比各自左子树上所有节点值要大，也都比各自右子树上所有节点值要小。
>
> 中序便利一定是从小到大排列的。

![image-20201210090149780](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210090149780.png)

> 可以按照上面的投影进行排序展示。

> 平衡性：
>
> 红黑树是一种含有红黑节点并能自平衡的二叉查找树。
>
> 红黑树是**非完美平衡二叉查找树**，是**完美黑色平衡二叉查找树**。

![image-20201210100556979](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210100556979.png)

![image-20201210115140865](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210115140865.png)

#### 红黑树的自平衡

> 包括：变色，旋转（左旋和右旋）->  (圆心，方向)。

### 查找

> 性质：
> **1** 从根结点开始查找，把根结点设置为当前结点；
> **2** 若当前结点为空，返回null；
> **3**若当前结点不为空，用当前结点的key跟查找key作比较；
> **4**若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；
> **5**若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；
> **6**若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；

![image-20201210110532800](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210110532800.png)

### 新增

![image-20201210111808405](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210111808405.png)

> 情况1：C = root
>
> 情况2：C.parent=black
>
> 情况3：C.parent = red & C.uncle = red
>
> 情况4：C.parent = red & (C.uncle=black or C.uncle = nil)

![image-20201210114737472](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210114737472.png)

#### 情况1：

![image-20201210115315875](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210115315875.png)

![image-20201210115714066](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210115714066.png)

#### 情况2：

![image-20201210115608699](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210115608699.png)

![image-20201210115815771](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210115815771.png)

#### 情况3：

![image-20201210122634741](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210122634741.png)

![image-20201210123043988](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210123043988.png)

![image-20201210115849535](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210115849535.png)

##### 4.1	CPG三点一线（左旋，右旋）

![image-20201210121408787](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210121408787.png)![image-20201210121457663](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210121457663.png)

###### 4.1.1 左旋

![left](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\left.gif)



###### 4.1.2 右旋

![right](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\right.gif)

##### 4.2	CPG三角关系

> 之后按照CPG三点一线来处理

![image-20201210122425750](E:\培训笔记\培训笔记\java集合笔记\红黑树_files\image-20201210122425750.png)



#### 左旋

```java
LEFT-ROTATE(T, x)  
 y ← right[x]            // 前提：这里假设x的右孩子为y。下面开始正式操作
 right[x] ← left[y]      // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子
 p[left[y]] ← x          // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x
 p[y] ← p[x]             // 将 “x的父亲” 设为 “y的父亲”
 if p[x] = nil[T]       
 then root[T] ← y                 // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点
 else if x = left[p[x]]  
           then left[p[x]] ← y    // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
           else right[p[x]] ← y   // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”
 left[y] ← x             // 将 “x” 设为 “y的左孩子”
 p[x] ← y                // 将 “x的父节点” 设为 “y”
```













